
\chapter{Internal Cell Library}
\label{chapter:celllib}

Most of the passes in Yosys operate on netlists, i.e.~they only care about the RTLIL::Wire and RTLIL::Cell
objects in an RTLIL::Module. This chapter discusses the cell types used by Yosys to represent a behavioural
design internally.

This chapter is split in two parts. In the first part the internal RTL cells are covered. These cells
are used to represent the design on a coarse grain level. Like in the original HDL code on this level the
cells operate on vectors of signals and complex cells like adders exist. In the second part the internal
gate cells are covered. These cells are used to represent the design on a fine-grain gate-level. All cells
from this category operate on single bit signals.

\section{RTL Cells}

Most of the RTL cells closely resemble the operators available in HDLs such as
Verilog or VHDL. Therefore Verilog operators are used in the following sections
to define the behaviour of the RTL cells.

Note that all RTL cells have parameters indicating the size of inputs and outputs. When
passes modify RTL cells they must always keep the values of these parameters in sync with
the size of the signals connected to the inputs and outputs.

Simulation models for the RTL cells can be found in the file {\tt techlibs/common/simlib.v} in the Yosys
source tree.

\subsection{Unary Operators}

All unary RTL cells have one input port \B{A} and one output port \B{Y}. They also
have the following parameters:

\begin{itemize}
\item \B{A\_SIGNED} \\
Set to a non-zero value if the input \B{A} is signed and therefore should be sign-extended
when needed.

\item \B{A\_WIDTH} \\
The width of the input port \B{A}.

\item \B{Y\_WIDTH} \\
The width of the output port \B{Y}.
\end{itemize}

Table~\ref{tab:CellLib_unary} lists all cells for unary RTL operators.

\begin{table}[t!]
\hfil
\begin{tabular}{ll}
Verilog & Cell Type \\
\hline
\lstinline[language=Verilog]; Y =  ~A ; & {\tt \$not} \\
\lstinline[language=Verilog]; Y =  +A ; & {\tt \$pos} \\
\lstinline[language=Verilog]; Y =  -A ; & {\tt \$neg} \\
\hline
\lstinline[language=Verilog]; Y =  &A ; & {\tt \$reduce\_and} \\
\lstinline[language=Verilog]; Y =  |A ; & {\tt \$reduce\_or} \\
\lstinline[language=Verilog]; Y =  ^A ; & {\tt \$reduce\_xor} \\
\lstinline[language=Verilog]; Y = ~^A ; & {\tt \$reduce\_xnor} \\
\hline
\lstinline[language=Verilog]; Y =  |A ; & {\tt \$reduce\_bool} \\
\lstinline[language=Verilog]; Y =  !A ; & {\tt \$logic\_not}
\end{tabular}
\caption{Cell types for unary operators with their corresponding Verilog expressions.}
\label{tab:CellLib_unary}
\end{table}

For the unary cells that output a logical value ({\tt \$reduce\_and}, {\tt \$reduce\_or},
{\tt \$reduce\_xor}, {\tt \$reduce\_xnor}, {\tt \$reduce\_bool}, {\tt \$logic\_not}),
when the \B{Y\_WIDTH} parameter is greater than 1, the output is zero-extended,
and only the least significant bit varies.

Note that {\tt \$reduce\_or} and {\tt \$reduce\_bool} actually represent the same
logic function. But the HDL frontends generate them in different situations. A
{\tt \$reduce\_or} cell is generated when the prefix {\tt |} operator is being used. A
{\tt \$reduce\_bool} cell is generated when a bit vector is used as a condition in
an {\tt if}-statement or {\tt ?:}-expression.

\subsection{Binary Operators}

All binary RTL cells have two input ports \B{A} and \B{B} and one output port \B{Y}. They
also have the following parameters:

\begin{itemize}
\item \B{A\_SIGNED} \\
Set to a non-zero value if the input \B{A} is signed and therefore should be sign-extended
when needed.

\item \B{A\_WIDTH} \\
The width of the input port \B{A}.

\item \B{B\_SIGNED} \\
Set to a non-zero value if the input \B{B} is signed and therefore should be sign-extended
when needed.

\item \B{B\_WIDTH} \\
The width of the input port \B{B}.

\item \B{Y\_WIDTH} \\
The width of the output port \B{Y}.
\end{itemize}

Table~\ref{tab:CellLib_binary} lists all cells for binary RTL operators.

\begin{table}[t!]
\hfil
\begin{tabular}[t]{ll}
Verilog & Cell Type \\
\hline
\lstinline[language=Verilog]; Y = A  & B; & {\tt \$and} \\
\lstinline[language=Verilog]; Y = A  | B; & {\tt \$or} \\
\lstinline[language=Verilog]; Y = A  ^ B; & {\tt \$xor} \\
\lstinline[language=Verilog]; Y = A ~^ B; & {\tt \$xnor} \\
\hline
\lstinline[language=Verilog]; Y = A << B; & {\tt \$shl} \\
\lstinline[language=Verilog]; Y = A >> B; & {\tt \$shr} \\
\lstinline[language=Verilog]; Y = A <<< B; & {\tt \$sshl} \\
\lstinline[language=Verilog]; Y = A >>> B; & {\tt \$sshr} \\
\hline
\lstinline[language=Verilog]; Y = A && B; & {\tt \$logic\_and} \\
\lstinline[language=Verilog]; Y = A || B; & {\tt \$logic\_or} \\
\hline
\lstinline[language=Verilog]; Y = A === B; & {\tt \$eqx} \\
\lstinline[language=Verilog]; Y = A !== B; & {\tt \$nex} \\
\end{tabular}
\hfil
\begin{tabular}[t]{ll}
Verilog & Cell Type \\
\hline
\lstinline[language=Verilog]; Y = A <  B; & {\tt \$lt} \\
\lstinline[language=Verilog]; Y = A <= B; & {\tt \$le} \\
\lstinline[language=Verilog]; Y = A == B; & {\tt \$eq} \\
\lstinline[language=Verilog]; Y = A != B; & {\tt \$ne} \\
\lstinline[language=Verilog]; Y = A >= B; & {\tt \$ge} \\
\lstinline[language=Verilog]; Y = A >  B; & {\tt \$gt} \\
\hline
\lstinline[language=Verilog]; Y = A  + B; & {\tt \$add} \\
\lstinline[language=Verilog]; Y = A  - B; & {\tt \$sub} \\
\lstinline[language=Verilog]; Y = A  * B; & {\tt \$mul} \\
\lstinline[language=Verilog]; Y = A  / B; & {\tt \$div} \\
\lstinline[language=Verilog]; Y = A  % B; & {\tt \$mod} \\
\multicolumn{1}{c}{\tt [N/A]} & {\tt \$divfloor} \\
\multicolumn{1}{c}{\tt [N/A]} & {\tt \$modfoor} \\
\lstinline[language=Verilog]; Y = A ** B; & {\tt \$pow} \\
\end{tabular}
\caption{Cell types for binary operators with their corresponding Verilog expressions.}
\label{tab:CellLib_binary}
\end{table}

The {\tt \$shl} and {\tt \$shr} cells implement logical shifts, whereas the {\tt \$sshl} and
{\tt \$sshr} cells implement arithmetic shifts. The {\tt \$shl} and {\tt \$sshl} cells implement
the same operation. All four of these cells interpret the second operand as unsigned, and require
\B{B\_SIGNED} to be zero.

Two additional shift operator cells are available that do not directly correspond to any operator
in Verilog, {\tt \$shift} and {\tt \$shiftx}. The {\tt \$shift} cell performs a right logical shift
if the second operand is positive (or unsigned), and a left logical shift if it is negative.
The {\tt \$shiftx} cell performs the same operation as the {\tt \$shift} cell, but the vacated bit
positions are filled with undef (x) bits, and corresponds to the Verilog indexed part-select expression.

For the binary cells that output a logical value ({\tt \$logic\_and}, {\tt \$logic\_or},
{\tt \$eqx}, {\tt \$nex}, {\tt \$lt}, {\tt \$le}, {\tt \$eq}, {\tt \$ne}, {\tt \$ge},
{\tt \$gt}), when the \B{Y\_WIDTH} parameter is greater than 1, the output is zero-extended,
and only the least significant bit varies.

Division and modulo cells are available in two rounding modes. The original {\tt \$div} and {\tt \$mod}
cells are based on truncating division, and correspond to the semantics of the verilog {\tt /} and
{\tt \%} operators. The {\tt \$divfloor} and {\tt \$modfloor} cells represent flooring division and
flooring modulo, the latter of which is also known as ``remainder'' in several languages. See
table~\ref{tab:CellLib_divmod} for a side-by-side comparison between the different semantics.

\begin{table}[h]
\hfil
\begin{tabular}{lr|rr|rr}
\multirow{2}{*}{Division} & \multirow{2}{*}{Result} & \multicolumn{2}{c|}{Truncating} & \multicolumn{2}{c}{Flooring} \\
               &            & {\tt \$div} & {\tt \$mod} & {\tt \$divfloor} & {\tt \$modfloor} \\
\hline
{\tt -10 / 3}  & {\tt -3.3} & {\tt -3}    & {\tt -1}    & {\tt -4}         & {\tt 2} \\
{\tt 10 / -3}  & {\tt -3.3} & {\tt -3}    & {\tt 1}     & {\tt -4}         & {\tt -2} \\
{\tt -10 / -3} & {\tt 3.3}  & {\tt 3}     & {\tt -1}    & {\tt 3}          & {\tt -1} \\
{\tt 10 / 3}   & {\tt 3.3}  & {\tt 3}     & {\tt 1}     & {\tt 3}          & {\tt 1} \\
\end{tabular}
\caption{Comparison between different rounding modes for division and modulo cells.}
\label{tab:CellLib_divmod}
\end{table}

\subsection{Multiplexers}

Multiplexers are generated by the Verilog HDL frontend for {\tt
?:}-expressions. Multiplexers are also generated by the {\tt proc} pass to map the decision trees
from RTLIL::Process objects to logic.

The simplest multiplexer cell type is {\tt \$mux}. Cells of this type have a \B{WIDTH} parameter
and data inputs \B{A} and \B{B} and a data output \B{Y}, all of the specified width. This cell also
has a single bit control input \B{S}. If \B{S} is 0 the value from the \B{A} input is sent to
the output, if it is 1 the value from the \B{B} input is sent to the output. So the {\tt \$mux}
cell implements the function \lstinline[language=Verilog]; Y = S ? B : A;.

The {\tt \$pmux} cell is used to multiplex between many inputs using a one-hot select signal. Cells
of this type have a \B{WIDTH} and a \B{S\_WIDTH} parameter and inputs \B{A}, \B{B}, and \B{S} and
an output \B{Y}. The \B{S} input is \B{S\_WIDTH} bits wide. The \B{A} input and the output are both
\B{WIDTH} bits wide and the \B{B} input is \B{WIDTH}*\B{S\_WIDTH} bits wide. When all bits of
\B{S} are zero, the value from \B{A} input is sent to the output. If the $n$'th bit from \B{S} is
set, the value $n$'th \B{WIDTH} bits wide slice of the \B{B} input is sent to the output. When more
than one bit from \B{S} is set the output is undefined. Cells of this type are used to model
``parallel cases'' (defined by using the {\tt parallel\_case} attribute or detected by
an optimization).

The {\tt \$tribuf} cell is used to implement tristate logic. Cells of this type have a \B{WIDTH}
parameter and inputs \B{A} and \B{EN} and an output \B{Y}. The \B{A} input and \B{Y} output are
\B{WIDTH} bits wide, and the \B{EN} input is one bit wide. When \B{EN} is 0, the output \B{Y}
is not driven. When \B{EN} is 1, the value from \B{A} input is sent to the \B{Y} output. Therefore,
the {\tt \$tribuf} cell implements the function \lstinline[language=Verilog]; Y = EN ? A : 'bz;.

Behavioural code with cascaded {\tt if-then-else}- and {\tt case}-statements
usually results in trees of multiplexer cells. Many passes (from various
optimizations to FSM extraction) heavily depend on these multiplexer trees to
understand dependencies between signals. Therefore optimizations should not
break these multiplexer trees (e.g.~by replacing a multiplexer between a
calculated signal and a constant zero with an {\tt \$and} gate).

\subsection{Registers}

SR-type latches are represented by {\tt \$sr} cells.  These cells have input ports
\B{SET} and \B{CLR} and an output port \B{Q}.  They have the following parameters:

\begin{itemize}
\item \B{WIDTH} \\
The width of inputs \B{SET} and \B{CLR} and output \B{Q}.

\item \B{SET\_POLARITY} \\
The set input bits are active-high if this parameter has the value {\tt 1'b1} and active-low
if this parameter is {\tt 1'b0}.

\item \B{CLR\_POLARITY} \\
The reset input bits are active-high if this parameter has the value {\tt 1'b1} and active-low
if this parameter is {\tt 1'b0}.
\end{itemize}

Both set and reset inputs have separate bits for every output bit.
When both the set and reset inputs of an {\tt \$sr} cell are active for a given bit
index, the reset input takes precedence.

D-type flip-flops are represented by {\tt \$dff} cells. These cells have a clock port \B{CLK},
an input port \B{D} and an output port \B{Q}. The following parameters are available for {\tt \$dff}
cells:

\begin{itemize}
\item \B{WIDTH} \\
The width of input \B{D} and output \B{Q}.

\item \B{CLK\_POLARITY} \\
Clock is active on the positive edge if this parameter has the value {\tt 1'b1} and on the negative
edge if this parameter is {\tt 1'b0}.
\end{itemize}

D-type flip-flops with asynchronous reset are represented by {\tt \$adff} cells. As the {\tt \$dff}
cells they have \B{CLK}, \B{D} and \B{Q} ports. In addition they also have a single-bit \B{ARST}
input port for the reset pin and the following additional two parameters:

\begin{itemize}
\item \B{ARST\_POLARITY} \\
The asynchronous reset is active-high if this parameter has the value {\tt 1'b1} and active-low
if this parameter is {\tt 1'b0}.

\item \B{ARST\_VALUE} \\
The state of \B{Q} will be set to this value when the reset is active.
\end{itemize}

\begin{sloppypar}
Usually these cells are generated by the {\tt proc} pass using the information
in the designs RTLIL::Process objects.
\end{sloppypar}

D-type flip-flops with synchronous reset are represented by {\tt \$sdff} cells. As the {\tt \$dff}
cells they have \B{CLK}, \B{D} and \B{Q} ports. In addition they also have a single-bit \B{SRST}
input port for the reset pin and the following additional two parameters:

\begin{itemize}
\item \B{SRST\_POLARITY} \\
The synchronous reset is active-high if this parameter has the value {\tt 1'b1} and active-low
if this parameter is {\tt 1'b0}.

\item \B{SRST\_VALUE} \\
The state of \B{Q} will be set to this value when the reset is active.
\end{itemize}

Note that the {\tt \$adff} and {\tt \$sdff} cells can only be used when the reset value is constant.

D-type flip-flops with asynchronous set and reset are represented by {\tt \$dffsr} cells.
As the {\tt \$dff} cells they have \B{CLK}, \B{D} and \B{Q} ports. In addition they also have
multi-bit \B{SET} and \B{CLR} input ports and the corresponding polarity parameters, like 
{\tt \$sr} cells.

D-type flip-flops with enable are represented by {\tt \$dffe}, {\tt \$adffe}, {\tt \$dffsre},
{\tt \$sdffe}, and {\tt \$sdffce} cells, which are enhanced variants of {\tt \$dff}, {\tt \$adff}, {\tt \$dffsr},
{\tt \$sdff} (with reset over enable) and {\tt \$sdff} (with enable over reset)
cells, respectively.  They have the same ports and parameters as their base cell.
In addition they also have a single-bit \B{EN} input port for the enable pin and the following parameter:

\begin{itemize}
\item \B{EN\_POLARITY} \\
The enable input is active-high if this parameter has the value {\tt 1'b1} and active-low
if this parameter is {\tt 1'b0}.
\end{itemize}

D-type latches are represented by {\tt \$dlatch} cells.  These cells have an enable port \B{EN},
an input port \B{D}, and an output port \B{Q}.  The following parameters are available for {\tt \$dlatch} cells:

\begin{itemize}
\item \B{WIDTH} \\
The width of input \B{D} and output \B{Q}.

\item \B{EN\_POLARITY} \\
The enable input is active-high if this parameter has the value {\tt 1'b1} and active-low
if this parameter is {\tt 1'b0}.
\end{itemize}

The latch is transparent when the \B{EN} input is active.

D-type latches with reset are represented by {\tt \$adlatch} cells.  In addition to {\tt \$dlatch}
ports and parameters, they also have a single-bit \B{ARST} input port for the reset pin and the following additional parameters:

\begin{itemize}
\item \B{ARST\_POLARITY} \\
The asynchronous reset is active-high if this parameter has the value {\tt 1'b1} and active-low
if this parameter is {\tt 1'b0}.

\item \B{ARST\_VALUE} \\
The state of \B{Q} will be set to this value when the reset is active.
\end{itemize}

D-type latches with set and reset are represented by {\tt \$dlatchsr} cells.
In addition to {\tt \$dlatch} ports and parameters, they also have multi-bit
\B{SET} and \B{CLR} input ports and the corresponding polarity parameters, like
{\tt \$sr} cells.

\subsection{Memories}
\label{sec:memcells}

Memories are either represented using RTLIL::Memory objects, {\tt \$memrd}, {\tt \$memwr}, and {\tt \$meminit}
cells, or by {\tt \$mem} cells alone.

In the first alternative the RTLIL::Memory objects hold the general metadata for the memory (bit width,
size in number of words, etc.) and for each port a {\tt \$memrd} (read port) or {\tt \$memwr} (write port)
cell is created. Having individual cells for read and write ports has the advantage that they can be
consolidated using resource sharing passes. In some cases this drastically reduces the number of required
ports on the memory cell. In this alternative, memory initialization data is represented by {\tt \$meminit} cells,
which allow delaying constant folding for initialization addresses and data until after the frontend finishes.

The {\tt \$memrd} cells have a clock input \B{CLK}, an enable input \B{EN}, an
address input \B{ADDR}, and a data output \B{DATA}. They also have the
following parameters:

\begin{itemize}
\item \B{MEMID} \\
The name of the RTLIL::Memory object that is associated with this read port.

\item \B{ABITS} \\
The number of address bits (width of the \B{ADDR} input port).

\item \B{WIDTH} \\
The number of data bits (width of the \B{DATA} output port).

\item \B{CLK\_ENABLE} \\
When this parameter is non-zero, the clock is used. Otherwise this read port is asynchronous and
the \B{CLK} input is not used.

\item \B{CLK\_POLARITY} \\
Clock is active on the positive edge if this parameter has the value {\tt 1'b1} and on the negative
edge if this parameter is {\tt 1'b0}.

\item \B{TRANSPARENT} \\
If this parameter is set to {\tt 1'b1}, a read and write to the same address in the same cycle will
return the new value. Otherwise the old value is returned.
\end{itemize}

The {\tt \$memwr} cells have a clock input \B{CLK}, an enable input \B{EN} (one
enable bit for each data bit), an address input \B{ADDR} and a data input
\B{DATA}. They also have the following parameters:

\begin{itemize}
\item \B{MEMID} \\
The name of the RTLIL::Memory object that is associated with this write port.

\item \B{ABITS} \\
The number of address bits (width of the \B{ADDR} input port).

\item \B{WIDTH} \\
The number of data bits (width of the \B{DATA} output port).

\item \B{CLK\_ENABLE} \\
When this parameter is non-zero, the clock is used. Otherwise this write port is asynchronous and
the \B{CLK} input is not used.

\item \B{CLK\_POLARITY} \\
Clock is active on positive edge if this parameter has the value {\tt 1'b1} and on the negative
edge if this parameter is {\tt 1'b0}.

\item \B{PRIORITY} \\
The cell with the higher integer value in this parameter wins a write conflict.
\end{itemize}

The {\tt \$meminit} cells have an address input \B{ADDR} and a data input \B{DATA}, with the width
of the \B{DATA} port equal to \B{WIDTH} parameter times \B{WORDS} parameter. Both of the inputs
must resolve to a constant for synthesis to succeed.

\begin{itemize}
\item \B{MEMID} \\
The name of the RTLIL::Memory object that is associated with this initialization cell.

\item \B{ABITS} \\
The number of address bits (width of the \B{ADDR} input port).

\item \B{WIDTH} \\
The number of data bits per memory location.

\item \B{WORDS} \\
The number of consecutive memory locations initialized by this cell.

\item \B{PRIORITY} \\
The cell with the higher integer value in this parameter wins an initialization conflict.
\end{itemize}

The HDL frontend models a memory using RTLIL::Memory objects and asynchronous
{\tt \$memrd} and {\tt \$memwr} cells. The {\tt memory} pass (i.e.~its various sub-passes) migrates
{\tt \$dff} cells into the {\tt \$memrd} and {\tt \$memwr} cells making them synchronous, then
converts them to a single {\tt \$mem} cell and (optionally) maps this cell type
to {\tt \$dff} cells for the individual words and multiplexer-based address decoders for the read and
write interfaces. When the last step is disabled or not possible, a {\tt \$mem} cell is left in the design.

The {\tt \$mem} cell provides the following parameters:

\begin{itemize}
\item \B{MEMID} \\
The name of the original RTLIL::Memory object that became this {\tt \$mem} cell.

\item \B{SIZE} \\
The number of words in the memory.

\item \B{ABITS} \\
The number of address bits.

\item \B{WIDTH} \\
The number of data bits per word.

\item \B{INIT} \\
The initial memory contents.

\item \B{RD\_PORTS} \\
The number of read ports on this memory cell.

\item \B{RD\_CLK\_ENABLE} \\
This parameter is \B{RD\_PORTS} bits wide, containing a clock enable bit for each read port.

\item \B{RD\_CLK\_POLARITY} \\
This parameter is \B{RD\_PORTS} bits wide, containing a clock polarity bit for each read port.

\item \B{RD\_TRANSPARENT} \\
This parameter is \B{RD\_PORTS} bits wide, containing a transparent bit for each read port.

\item \B{WR\_PORTS} \\
The number of write ports on this memory cell.

\item \B{WR\_CLK\_ENABLE} \\
This parameter is \B{WR\_PORTS} bits wide, containing a clock enable bit for each write port.

\item \B{WR\_CLK\_POLARITY} \\
This parameter is \B{WR\_PORTS} bits wide, containing a clock polarity bit for each write port.
\end{itemize}

The {\tt \$mem} cell has the following ports:

\begin{itemize}
\item \B{RD\_CLK} \\
This input is \B{RD\_PORTS} bits wide, containing all clock signals for the read ports.

\item \B{RD\_EN} \\
This input is \B{RD\_PORTS} bits wide, containing all enable signals for the read ports.

\item \B{RD\_ADDR} \\
This input is \B{RD\_PORTS}*\B{ABITS} bits wide, containing all address signals for the read ports.

\item \B{RD\_DATA} \\
This input is \B{RD\_PORTS}*\B{WIDTH} bits wide, containing all data signals for the read ports.

\item \B{WR\_CLK} \\
This input is \B{WR\_PORTS} bits wide, containing all clock signals for the write ports.

\item \B{WR\_EN} \\
This input is \B{WR\_PORTS}*\B{WIDTH} bits wide, containing all enable signals for the write ports.

\item \B{WR\_ADDR} \\
This input is \B{WR\_PORTS}*\B{ABITS} bits wide, containing all address signals for the write ports.

\item \B{WR\_DATA} \\
This input is \B{WR\_PORTS}*\B{WIDTH} bits wide, containing all data signals for the write ports.
\end{itemize}

The {\tt memory\_collect} pass can be used to convert discrete {\tt \$memrd}, {\tt \$memwr}, and {\tt \$meminit} cells
belonging to the same memory to a single {\tt \$mem} cell, whereas the {\tt memory\_unpack} pass performs the inverse operation.
The {\tt memory\_dff} pass can combine asynchronous memory ports that are fed by or feeding registers into synchronous memory ports.
The {\tt memory\_bram} pass can be used to recognize {\tt \$mem} cells that can be implemented with a block RAM resource on an FPGA.
The {\tt memory\_map} pass can be used to implement {\tt \$mem} cells as basic logic: word-wide DFFs and address decoders.

\subsection{Finite State Machines}

\begin{fixme}
Add a brief description of the {\tt \$fsm} cell type.
\end{fixme}

\subsection{Specify rules}

\begin{fixme}
Add information about {\tt \$specify2}, {\tt \$specify3}, and {\tt \$specrule} cells.
\end{fixme}

\subsection{Formal verification cells}

\begin{fixme}
Add information about {\tt \$assert}, {\tt \$assume}, {\tt \$live}, {\tt \$fair}, {\tt \$cover}, {\tt \$equiv},
{\tt \$initstate}, {\tt \$anyconst}, {\tt \$anyseq}, {\tt \$allconst}, {\tt \$allseq} cells.
\end{fixme}

\begin{fixme}
Add information about {\tt \$ff} and {\tt \$\_FF\_} cells.
\end{fixme}

\section{Gates}
\label{sec:celllib_gates}

For gate level logic networks, fixed function single bit cells are used that do
not provide any parameters.

Simulation models for these cells can be found in the file {\tt techlibs/common/simcells.v} in the Yosys
source tree.

\begin{table}[t]
\hfil
\begin{tabular}[t]{ll}
Verilog & Cell Type \\
\hline
\lstinline[language=Verilog]; Y = A;     & {\tt \$\_BUF\_} \\
\lstinline[language=Verilog]; Y = ~A;    & {\tt \$\_NOT\_} \\
\lstinline[language=Verilog]; Y = A & B; & {\tt \$\_AND\_} \\
\lstinline[language=Verilog]; Y = ~(A & B); & {\tt \$\_NAND\_} \\
\lstinline[language=Verilog]; Y = A & ~B; & {\tt \$\_ANDNOT\_} \\
\lstinline[language=Verilog]; Y = A | B; & {\tt \$\_OR\_} \\
\lstinline[language=Verilog]; Y = ~(A | B); & {\tt \$\_NOR\_} \\
\lstinline[language=Verilog]; Y = A | ~B; & {\tt \$\_ORNOT\_} \\
\lstinline[language=Verilog]; Y = A ^ B; & {\tt \$\_XOR\_} \\
\lstinline[language=Verilog]; Y = ~(A ^ B); & {\tt \$\_XNOR\_} \\
\lstinline[language=Verilog]; Y = ~((A & B) | C); & {\tt \$\_AOI3\_} \\
\lstinline[language=Verilog]; Y = ~((A | B) & C); & {\tt \$\_OAI3\_} \\
\lstinline[language=Verilog]; Y = ~((A & B) | (C & D)); & {\tt \$\_AOI4\_} \\
\lstinline[language=Verilog]; Y = ~((A | B) & (C | D)); & {\tt \$\_OAI4\_} \\
\lstinline[language=Verilog]; Y = S ? B : A; & {\tt \$\_MUX\_} \\
\lstinline[language=Verilog]; Y = ~(S ? B : A); & {\tt \$\_NMUX\_} \\
(see below) & {\tt \$\_MUX4\_} \\
(see below) & {\tt \$\_MUX8\_} \\
(see below) & {\tt \$\_MUX16\_} \\
\lstinline[language=Verilog]; Y = EN ? A : 1'bz; & {\tt \$\_TBUF\_} \\
\hline
\lstinline[language=Verilog]; always @(negedge C) Q <= D; & {\tt \$\_DFF\_N\_} \\
\lstinline[language=Verilog]; always @(posedge C) Q <= D; & {\tt \$\_DFF\_P\_} \\
\lstinline[language=Verilog]; always @* if (!E) Q <= D; & {\tt \$\_DLATCH\_N\_} \\
\lstinline[language=Verilog]; always @* if (E)  Q <= D; & {\tt \$\_DLATCH\_P\_} \\
\end{tabular}
\caption{Cell types for gate level logic networks (main list)}
\label{tab:CellLib_gates}
\end{table}

\begin{table}[t]
\hfil
\begin{tabular}[t]{llll}
$ClkEdge$ & $RstLvl$ & $RstVal$ & Cell Type \\
\hline
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFF\_NN0\_}, {\tt \$\_SDFF\_NN0\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFF\_NN1\_}, {\tt \$\_SDFF\_NN1\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFF\_NP0\_}, {\tt \$\_SDFF\_NP0\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFF\_NP1\_}, {\tt \$\_SDFF\_NP1\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFF\_PN0\_}, {\tt \$\_SDFF\_PN0\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFF\_PN1\_}, {\tt \$\_SDFF\_PN1\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFF\_PP0\_}, {\tt \$\_SDFF\_PP0\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFF\_PP1\_}, {\tt \$\_SDFF\_PP1\_} \\
\end{tabular}
\caption{Cell types for gate level logic networks (FFs with reset)}
\label{tab:CellLib_gates_adff}
\end{table}

\begin{table}[t]
\hfil
\begin{tabular}[t]{lll}
$ClkEdge$ & $EnLvl$ & Cell Type \\
\hline
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & {\tt \$\_DFFE\_NN\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & {\tt \$\_DFFE\_NP\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & {\tt \$\_DFFE\_PN\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & {\tt \$\_DFFE\_PP\_} \\
\end{tabular}
\caption{Cell types for gate level logic networks (FFs with enable)}
\label{tab:CellLib_gates_dffe}
\end{table}

\begin{table}[t]
\begin{tabular}[t]{lllll}
$ClkEdge$ & $RstLvl$ & $RstVal$ & $EnLvl$ & Cell Type \\
\hline
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFFE\_NN0N\_}, {\tt \$\_SDFFE\_NN0N\_}, {\tt \$\_SDFFCE\_NN0N\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFFE\_NN0P\_}, {\tt \$\_SDFFE\_NN0P\_}, {\tt \$\_SDFFCE\_NN0P\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFFE\_NN1N\_}, {\tt \$\_SDFFE\_NN1N\_}, {\tt \$\_SDFFCE\_NN1N\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFFE\_NN1P\_}, {\tt \$\_SDFFE\_NN1P\_}, {\tt \$\_SDFFCE\_NN1P\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFFE\_NP0N\_}, {\tt \$\_SDFFE\_NP0N\_}, {\tt \$\_SDFFCE\_NP0N\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFFE\_NP0P\_}, {\tt \$\_SDFFE\_NP0P\_}, {\tt \$\_SDFFCE\_NP0P\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFFE\_NP1N\_}, {\tt \$\_SDFFE\_NP1N\_}, {\tt \$\_SDFFCE\_NP1N\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFFE\_NP1P\_}, {\tt \$\_SDFFE\_NP1P\_}, {\tt \$\_SDFFCE\_NP1P\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFFE\_PN0N\_}, {\tt \$\_SDFFE\_PN0N\_}, {\tt \$\_SDFFCE\_PN0N\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFFE\_PN0P\_}, {\tt \$\_SDFFE\_PN0P\_}, {\tt \$\_SDFFCE\_PN0P\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFFE\_PN1N\_}, {\tt \$\_SDFFE\_PN1N\_}, {\tt \$\_SDFFCE\_PN1N\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFFE\_PN1P\_}, {\tt \$\_SDFFE\_PN1P\_}, {\tt \$\_SDFFCE\_PN1P\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFFE\_PP0N\_}, {\tt \$\_SDFFE\_PP0N\_}, {\tt \$\_SDFFCE\_PP0N\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFFE\_PP0P\_}, {\tt \$\_SDFFE\_PP0P\_}, {\tt \$\_SDFFCE\_PP0P\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFFE\_PP1N\_}, {\tt \$\_SDFFE\_PP1N\_}, {\tt \$\_SDFFCE\_PP1N\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFFE\_PP1P\_}, {\tt \$\_SDFFE\_PP1P\_}, {\tt \$\_SDFFCE\_PP1P\_} \\
\end{tabular}
\caption{Cell types for gate level logic networks (FFs with reset and enable)}
\label{tab:CellLib_gates_adffe}
\end{table}

\begin{table}[t]
\hfil
\begin{tabular}[t]{llll}
$ClkEdge$ & $SetLvl$ & $RstLvl$ & Cell Type \\
\hline
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSR\_NNN\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSR\_NNP\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSR\_NPN\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSR\_NPP\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSR\_PNN\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSR\_PNP\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSR\_PPN\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSR\_PPP\_} \\
\end{tabular}
\caption{Cell types for gate level logic networks (FFs with set and reset)}
\label{tab:CellLib_gates_dffsr}
\end{table}

\begin{table}[t]
\hfil
\begin{tabular}[t]{lllll}
$ClkEdge$ & $SetLvl$ & $RstLvl$ & $EnLvl$ & Cell Type \\
\hline
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSRE\_NNNN\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSRE\_NNNP\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSRE\_NNPN\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSRE\_NNPP\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSRE\_NPNN\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSRE\_NPNP\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSRE\_NPPN\_} \\
\lstinline[language=Verilog];negedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSRE\_NPPP\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSRE\_PNNN\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSRE\_PNNP\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSRE\_PNPN\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSRE\_PNPP\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSRE\_PPNN\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSRE\_PPNP\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DFFSRE\_PPPN\_} \\
\lstinline[language=Verilog];posedge; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DFFSRE\_PPPP\_} \\
\end{tabular}
\caption{Cell types for gate level logic networks (FFs with set and reset and enable)}
\label{tab:CellLib_gates_dffsre}
\end{table}

\begin{table}[t]
\hfil
\begin{tabular}[t]{llll}
$EnLvl$ & $RstLvl$ & $RstVal$ & Cell Type \\
\hline
\lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DLATCH\_NN0\_} \\
\lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DLATCH\_NN1\_} \\
\lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DLATCH\_NP0\_} \\
\lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DLATCH\_NP1\_} \\
\lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DLATCH\_PN0\_} \\
\lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DLATCH\_PN1\_} \\
\lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DLATCH\_PP0\_} \\
\lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DLATCH\_PP1\_} \\
\end{tabular}
\caption{Cell types for gate level logic networks (latches with reset)}
\label{tab:CellLib_gates_adlatch}
\end{table}

\begin{table}[t]
\hfil
\begin{tabular}[t]{llll}
$EnLvl$ & $SetLvl$ & $RstLvl$ & Cell Type \\
\hline
\lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DLATCHSR\_NNN\_} \\
\lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DLATCHSR\_NNP\_} \\
\lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DLATCHSR\_NPN\_} \\
\lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DLATCHSR\_NPP\_} \\
\lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_DLATCHSR\_PNN\_} \\
\lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_DLATCHSR\_PNP\_} \\
\lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_DLATCHSR\_PPN\_} \\
\lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_DLATCHSR\_PPP\_} \\
\end{tabular}
\caption{Cell types for gate level logic networks (latches with set and reset)}
\label{tab:CellLib_gates_dlatchsr}
\end{table}

\begin{table}[t]
\hfil
\begin{tabular}[t]{llll}
$SetLvl$ & $RstLvl$ & Cell Type \\
\hline
\lstinline[language=Verilog];0; & \lstinline[language=Verilog];0; & {\tt \$\_SR\_NN\_} \\
\lstinline[language=Verilog];0; & \lstinline[language=Verilog];1; & {\tt \$\_SR\_NP\_} \\
\lstinline[language=Verilog];1; & \lstinline[language=Verilog];0; & {\tt \$\_SR\_PN\_} \\
\lstinline[language=Verilog];1; & \lstinline[language=Verilog];1; & {\tt \$\_SR\_PP\_} \\
\end{tabular}
\caption{Cell types for gate level logic networks (SR latches)}
\label{tab:CellLib_gates_sr}
\end{table}

Tables~\ref{tab:CellLib_gates}, \ref{tab:CellLib_gates_dffe}, \ref{tab:CellLib_gates_adff}, \ref{tab:CellLib_gates_adffe}, \ref{tab:CellLib_gates_dffsr}, \ref{tab:CellLib_gates_dffsre}, \ref{tab:CellLib_gates_adlatch}, \ref{tab:CellLib_gates_dlatchsr} and \ref{tab:CellLib_gates_sr} list all cell types used for gate level logic. The cell types
{\tt \$\_BUF\_}, {\tt \$\_NOT\_}, {\tt \$\_AND\_}, {\tt \$\_NAND\_}, {\tt \$\_ANDNOT\_},
{\tt \$\_OR\_}, {\tt \$\_NOR\_}, {\tt \$\_ORNOT\_}, {\tt \$\_XOR\_}, {\tt \$\_XNOR\_},
{\tt \$\_AOI3\_}, {\tt \$\_OAI3\_}, {\tt \$\_AOI4\_}, {\tt \$\_OAI4\_},
{\tt \$\_MUX\_}, {\tt \$\_MUX4\_}, {\tt \$\_MUX8\_}, {\tt \$\_MUX16\_} and {\tt \$\_NMUX\_} are used to model combinatorial logic.
The cell type {\tt \$\_TBUF\_} is used to model tristate logic.

The {\tt \$\_MUX4\_}, {\tt \$\_MUX8\_} and {\tt \$\_MUX16\_} cells are used to model wide muxes, and correspond to the following Verilog code:

\begin{lstlisting}[language=Verilog]
// $_MUX4_
assign Y = T ? (S ? D : C) :
               (S ? B : A);
// $_MUX8_
assign Y = U ? T ? (S ? H : G) :
                   (S ? F : E) :
               T ? (S ? D : C) :
                   (S ? B : A);
// $_MUX16_
assign Y = V ? U ? T ? (S ? P : O) :
                       (S ? N : M) :
                   T ? (S ? L : K) :
                       (S ? J : I) :
               U ? T ? (S ? H : G) :
                       (S ? F : E) :
                   T ? (S ? D : C) :
                       (S ? B : A);
\end{lstlisting}

The cell types {\tt \$\_DFF\_N\_} and {\tt \$\_DFF\_P\_} represent d-type flip-flops.

The cell types {\tt \$\_DFFE\_[NP][NP]\_}
implement d-type flip-flops with enable. The values in the table for these cell types relate to the
following Verilog code template.

\begin{lstlisting}[mathescape,language=Verilog]
	always @($ClkEdge$ C)
		if (EN == $EnLvl$)
			Q <= D;
\end{lstlisting}

The cell types {\tt \$\_DFF\_[NP][NP][01]\_} implement
d-type flip-flops with asynchronous reset. The values in the table for these cell types relate to the
following Verilog code template, where \lstinline[mathescape,language=Verilog];$RstEdge$; is \lstinline[language=Verilog];posedge;
if \lstinline[mathescape,language=Verilog];$RstLvl$; if \lstinline[language=Verilog];1;, and \lstinline[language=Verilog];negedge;
otherwise.

\begin{lstlisting}[mathescape,language=Verilog]
	always @($ClkEdge$ C, $RstEdge$ R)
		if (R == $RstLvl$)
			Q <= $RstVal$;
		else
			Q <= D;
\end{lstlisting}

The cell types {\tt \$\_SDFF\_[NP][NP][01]\_} implement
d-type flip-flops with synchronous reset. The values in the table for these cell types relate to the
following Verilog code template:

\begin{lstlisting}[mathescape,language=Verilog]
	always @($ClkEdge$ C)
		if (R == $RstLvl$)
			Q <= $RstVal$;
		else
			Q <= D;
\end{lstlisting}

The cell types {\tt \$\_DFFE\_[NP][NP][01][NP]\_} implement
d-type flip-flops with asynchronous reset and enable.  The values in the table for these cell types relate to the
following Verilog code template, where \lstinline[mathescape,language=Verilog];$RstEdge$; is \lstinline[language=Verilog];posedge;
if \lstinline[mathescape,language=Verilog];$RstLvl$; if \lstinline[language=Verilog];1;, and \lstinline[language=Verilog];negedge;
otherwise.

\begin{lstlisting}[mathescape,language=Verilog]
	always @($ClkEdge$ C, $RstEdge$ R)
		if (R == $RstLvl$)
			Q <= $RstVal$;
		else if (EN == $EnLvl$)
			Q <= D;
\end{lstlisting}

The cell types {\tt \$\_SDFFE\_[NP][NP][01][NP]\_} implement d-type flip-flops
with synchronous reset and enable, with reset having priority over enable.
The values in the table for these cell types relate to the
following Verilog code template:

\begin{lstlisting}[mathescape,language=Verilog]
	always @($ClkEdge$ C)
		if (R == $RstLvl$)
			Q <= $RstVal$;
		else if (EN == $EnLvl$)
			Q <= D;
\end{lstlisting}

The cell types {\tt \$\_SDFFCE\_[NP][NP][01][NP]\_} implement d-type flip-flops
with synchronous reset and enable, with enable having priority over reset.
The values in the table for these cell types relate to the
following Verilog code template:

\begin{lstlisting}[mathescape,language=Verilog]
	always @($ClkEdge$ C)
		if (EN == $EnLvl$)
			if (R == $RstLvl$)
				Q <= $RstVal$;
			else
				Q <= D;
\end{lstlisting}

The cell types {\tt \$\_DFFSR\_[NP][NP][NP]\_} implement
d-type flip-flops with asynchronous set and reset. The values in the table for these cell types relate to the
following Verilog code template, where \lstinline[mathescape,language=Verilog];$RstEdge$; is \lstinline[language=Verilog];posedge;
if \lstinline[mathescape,language=Verilog];$RstLvl$; if \lstinline[language=Verilog];1;, \lstinline[language=Verilog];negedge;
otherwise, and \lstinline[mathescape,language=Verilog];$SetEdge$; is \lstinline[language=Verilog];posedge;
if \lstinline[mathescape,language=Verilog];$SetLvl$; if \lstinline[language=Verilog];1;, \lstinline[language=Verilog];negedge;
otherwise.

\begin{lstlisting}[mathescape,language=Verilog]
	always @($ClkEdge$ C, $RstEdge$ R, $SetEdge$ S)
		if (R == $RstLvl$)
			Q <= 0;
		else if (S == $SetLvl$)
			Q <= 1;
		else
			Q <= D;
\end{lstlisting}

The cell types {\tt \$\_DFFSRE\_[NP][NP][NP][NP]\_} implement
d-type flip-flops with asynchronous set and reset and enable. The values in the table for these cell types relate to the
following Verilog code template, where \lstinline[mathescape,language=Verilog];$RstEdge$; is \lstinline[language=Verilog];posedge;
if \lstinline[mathescape,language=Verilog];$RstLvl$; if \lstinline[language=Verilog];1;, \lstinline[language=Verilog];negedge;
otherwise, and \lstinline[mathescape,language=Verilog];$SetEdge$; is \lstinline[language=Verilog];posedge;
if \lstinline[mathescape,language=Verilog];$SetLvl$; if \lstinline[language=Verilog];1;, \lstinline[language=Verilog];negedge;
otherwise.

\begin{lstlisting}[mathescape,language=Verilog]
	always @($ClkEdge$ C, $RstEdge$ R, $SetEdge$ S)
		if (R == $RstLvl$)
			Q <= 0;
		else if (S == $SetLvl$)
			Q <= 1;
		else if (E == $EnLvl$)
			Q <= D;
\end{lstlisting}

The cell types {\tt \$\_DLATCH\_N\_} and {\tt \$\_DLATCH\_P\_} represent d-type latches.

The cell types {\tt \$\_DLATCH\_[NP][NP][01]\_} implement
d-type latches with reset. The values in the table for these cell types relate to the
following Verilog code template:

\begin{lstlisting}[mathescape,language=Verilog]
	always @*
		if (R == $RstLvl$)
			Q <= $RstVal$;
		else if (E == $EnLvl$)
			Q <= D;
\end{lstlisting}

The cell types {\tt \$\_DLATCHSR\_[NP][NP][NP]\_} implement
d-type latches with set and reset. The values in the table for these cell types relate to the
following Verilog code template:

\begin{lstlisting}[mathescape,language=Verilog]
	always @*
		if (R == $RstLvl$)
			Q <= 0;
		else if (S == $SetLvl$)
			Q <= 1;
		else if (E == $EnLvl$)
			Q <= D;
\end{lstlisting}

The cell types {\tt \$\_SR\_[NP][NP]\_} implement
sr-type latches. The values in the table for these cell types relate to the
following Verilog code template:

\begin{lstlisting}[mathescape,language=Verilog]
	always @*
		if (R == $RstLvl$)
			Q <= 0;
		else if (S == $SetLvl$)
			Q <= 1;
\end{lstlisting}

In most cases gate level logic networks are created from RTL networks using the {\tt techmap} pass. The flip-flop cells
from the gate level logic network can be mapped to physical flip-flop cells from a Liberty file using the {\tt dfflibmap}
pass. The combinatorial logic cells can be mapped to physical cells from a Liberty file via ABC \citeweblink{ABC}
using the {\tt abc} pass.

\begin{fixme}
Add information about {\tt \$slice} and {\tt \$concat} cells.
\end{fixme}

\begin{fixme}
Add information about {\tt \$lut} and {\tt \$sop} cells.
\end{fixme}

\begin{fixme}
Add information about {\tt \$alu}, {\tt \$macc}, {\tt \$fa}, and {\tt \$lcu} cells.
\end{fixme}
