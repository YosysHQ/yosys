read_verilog -formal -icells <<EOT
module top(input clk, d, s, r, output reg [34:0] q);
always @(posedge clk or posedge s) if ( s) q[ 0] <= 1'b1; else q[ 0] <= d;
always @(posedge clk or negedge s) if (!s) q[ 1] <= 1'b1; else q[ 1] <= d;
always @(posedge clk or posedge r) if ( r) q[ 2] <= 1'b0; else q[ 2] <= d;
always @(posedge clk or negedge r) if (!r) q[ 3] <= 1'b0; else q[ 3] <= d;
always @(negedge clk or posedge s) if ( s) q[ 4] <= 1'b1; else q[ 4] <= d;
always @(negedge clk or negedge s) if (!s) q[ 5] <= 1'b1; else q[ 5] <= d;
always @(negedge clk or posedge r) if ( r) q[ 6] <= 1'b0; else q[ 6] <= d;
always @(negedge clk or negedge r) if (!r) q[ 7] <= 1'b0; else q[ 7] <= d;

always @(posedge clk or posedge s or posedge r) if ( r) q[ 8] <= 1'b0; else if ( s) q[ 8] <= 1'b1; else q[ 8] <= d;
always @(posedge clk or posedge s or negedge r) if (!r) q[ 9] <= 1'b0; else if ( s) q[ 9] <= 1'b1; else q[ 9] <= d;
always @(posedge clk or negedge s or posedge r) if ( r) q[10] <= 1'b0; else if (!s) q[10] <= 1'b1; else q[10] <= d;
always @(posedge clk or negedge s or negedge r) if (!r) q[11] <= 1'b0; else if (!s) q[11] <= 1'b1; else q[11] <= d;
$dffsr  #(.CLK_POLARITY(1'h1), .SET_POLARITY(1'h0), .CLR_POLARITY(1'h0), .WIDTH(32'd1)) pnn (.CLK(clk), .CLR(r), .D(d), .Q(q[12]), .SET(s));
$dffsr  #(.CLK_POLARITY(1'h1), .SET_POLARITY(1'h0), .CLR_POLARITY(1'h1), .WIDTH(32'd1)) pnp (.CLK(clk), .CLR(r), .D(d), .Q(q[13]), .SET(s));
$dffsr  #(.CLK_POLARITY(1'h1), .SET_POLARITY(1'h1), .CLR_POLARITY(1'h0), .WIDTH(32'd1)) ppn (.CLK(clk), .CLR(r), .D(d), .Q(q[14]), .SET(s));
$dffsr  #(.CLK_POLARITY(1'h1), .SET_POLARITY(1'h1), .CLR_POLARITY(1'h1), .WIDTH(32'd1)) ppp (.CLK(clk), .CLR(r), .D(d), .Q(q[15]), .SET(s));

always @(negedge clk or posedge s or posedge r) if ( r) q[16] <= 1'b0; else if ( s) q[16] <= 1'b1; else q[16] <= d;
always @(negedge clk or posedge s or negedge r) if (!r) q[17] <= 1'b0; else if ( s) q[17] <= 1'b1; else q[17] <= d;
always @(negedge clk or negedge s or posedge r) if ( r) q[18] <= 1'b0; else if (!s) q[18] <= 1'b1; else q[18] <= d;
always @(negedge clk or negedge s or negedge r) if (!r) q[19] <= 1'b0; else if (!s) q[19] <= 1'b1; else q[19] <= d;
$dffsr  #(.CLK_POLARITY(1'h0), .SET_POLARITY(1'h0), .CLR_POLARITY(1'h0), .WIDTH(32'd1)) nnn (.CLK(clk), .CLR(r), .D(d), .Q(q[20]), .SET(s));
$dffsr  #(.CLK_POLARITY(1'h0), .SET_POLARITY(1'h0), .CLR_POLARITY(1'h1), .WIDTH(32'd1)) nnp (.CLK(clk), .CLR(r), .D(d), .Q(q[21]), .SET(s));
$dffsr  #(.CLK_POLARITY(1'h0), .SET_POLARITY(1'h1), .CLR_POLARITY(1'h0), .WIDTH(32'd1)) npn (.CLK(clk), .CLR(r), .D(d), .Q(q[22]), .SET(s));
$dffsr  #(.CLK_POLARITY(1'h0), .SET_POLARITY(1'h1), .CLR_POLARITY(1'h1), .WIDTH(32'd1)) npp (.CLK(clk), .CLR(r), .D(d), .Q(q[23]), .SET(s));

always @(posedge clk or posedge r or posedge s) if ( s) q[24] <= 1'b1; else if ( r) q[24] <= 1'b0; else q[24] <= d;
always @(posedge clk or posedge r or negedge s) if (!s) q[25] <= 1'b1; else if ( r) q[25] <= 1'b0; else q[25] <= d;
always @(posedge clk or negedge r or posedge s) if ( s) q[26] <= 1'b1; else if (!r) q[26] <= 1'b0; else q[26] <= d;
always @(posedge clk or negedge r or negedge s) if (!s) q[27] <= 1'b1; else if (!r) q[27] <= 1'b0; else q[27] <= d;

always @(negedge clk or posedge r or posedge s) if ( s) q[28] <= 1'b1; else if ( r) q[28] <= 1'b0; else q[28] <= d;
always @(negedge clk or posedge r or negedge s) if (!s) q[29] <= 1'b1; else if ( r) q[29] <= 1'b0; else q[29] <= d;
always @(negedge clk or negedge r or posedge s) if ( s) q[30] <= 1'b1; else if (!r) q[30] <= 1'b0; else q[30] <= d;
always @(negedge clk or negedge r or negedge s) if (!s) q[31] <= 1'b1; else if (!r) q[31] <= 1'b0; else q[31] <= d;

always @(posedge clk) q[32] <= d;
always @(negedge clk) q[33] <= d;
endmodule
EOT
proc
select -assert-count 8 t:$adff
select -assert-count 24 t:$dffsr
select -assert-count 2 t:$dff
design -save gold

simplemap
select -assert-count 1 t:$_DFF_NN0_
select -assert-count 1 t:$_DFF_NN1_
select -assert-count 1 t:$_DFF_NP0_
select -assert-count 1 t:$_DFF_NP1_
select -assert-count 1 t:$_DFF_PN0_
select -assert-count 1 t:$_DFF_PN1_
select -assert-count 1 t:$_DFF_PP0_
select -assert-count 1 t:$_DFF_PP1_
stat
select -assert-count 3 t:$_DFFSR_NNN_
select -assert-count 3 t:$_DFFSR_NNP_
select -assert-count 3 t:$_DFFSR_NPN_
select -assert-count 3 t:$_DFFSR_NPP_
select -assert-count 3 t:$_DFFSR_PNN_
select -assert-count 3 t:$_DFFSR_PNP_
select -assert-count 3 t:$_DFFSR_PPN_
select -assert-count 3 t:$_DFFSR_PPP_
select -assert-count 1 t:$_DFF_N_
select -assert-count 1 t:$_DFF_P_
design -stash gate

design -import gold -as gold
design -import gate -as gate
clk2fflogic

miter -equiv -flatten -make_assert -make_outputs gold gate miter
sat -verify -prove-asserts -show-ports -set-init-undef -seq 10 miter
