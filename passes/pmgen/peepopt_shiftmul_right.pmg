pattern shiftmul_right
//
// Optimize mul+shift pairs that result from expressions such as foo[s*W+:W]
//

udata <bool> bmux_mode wshift_mode

match shift
	select shift->type.in($shift, $shiftx, $shr)
	filter !port(shift, \B).empty()
endmatch

// the right shift amount
state <SigSpec> shift_amount
// log2 scale factor in interpreting of shift_amount
// due to zero padding on the shift cell's B port
state <int> log2scale

code shift_amount log2scale
	shift_amount = port(shift, \B);
	if (shift->type.in($shr) || !param(shift, \B_SIGNED).as_bool())
		shift_amount.append(State::S0);

	// at this point shift_amount is signed, make
	// sure we can never go negative
	if (shift_amount.bits().back() != State::S0)
		reject;

	while (shift_amount.bits().back() == State::S0) {
		shift_amount.remove(GetSize(shift_amount) - 1);
		if (shift_amount.empty()) reject;
	}

	log2scale = 0;
	while (shift_amount[0] == State::S0) {
		shift_amount.remove(0);
		if (shift_amount.empty()) reject;
		log2scale++;
	}

	if (GetSize(shift_amount) > 20)
		reject;
endcode

state <SigSpec> mul_din
state <Const> mul_const

match mul
	select mul->type.in($mul)
	index <SigSpec> port(mul, \Y) === shift_amount
	filter !param(mul, \A_SIGNED).as_bool()

	choice <IdString> constport {\A, \B}
	filter port(mul, constport).is_fully_const()

	define <IdString> varport (constport == \A ? \B : \A)
	set mul_const SigSpec({port(mul, constport), SigSpec(State::S0, log2scale)}).as_const()
	// get mul_din unmapped (so no `port()` shorthand)
	// because we will be using it to set the \A port
	// on the shift cell, and we want to stay close
	// to the original design
	set mul_din mul->getPort(varport)
endmatch

code
{
	if (mul_const.empty() || GetSize(mul_const) > 20)
		reject;

	// make sure there's no overlap in the signal
	// selections by the shiftmul pattern
	if (GetSize(port(shift, \Y)) > mul_const.as_int())
	if (!bmux_mode && !wshift_mode)
		reject;

	int factor_bits = ceil_log2(mul_const.as_int());
	// make sure the multiplication never wraps around
	if (GetSize(shift_amount) + log2scale < factor_bits + GetSize(mul_din))
		reject;

	did_something = true;
	log("right shiftmul pattern in %s: shift=%s, mul=%s\n", log_id(module), log_id(shift), log_id(mul));

	if (bmux_mode) {
		SigSpec out = port(shift, \Y);
		int shift_stride = mul_const.as_int();
		SigSpec shift_vector = port(shift, \A);
		SigBit padbit = (shift->type != $shiftx) ? (param(shift, \A_SIGNED)).as_bool() ?
						port(shift, \A).bits().back() : State::S0 : State::Sx;

		// Construct the input vector for the new bmux cell
		SigSpec bmux_vector;
		for (int i = 0; i * shift_stride < GetSize(shift_vector); i++) {
			int validbits = std::min(GetSize(out),
									 GetSize(shift_vector) - i * shift_stride);
			bmux_vector.append(shift_vector.extract(i * shift_stride, validbits));
			bmux_vector.append(SigSpec(padbit, GetSize(out) - validbits));
		}

		// Prep the select signal
		SigSpec bmux_sel = mul_din;
		bmux_sel.extend_u0(ceil_log2((GetSize(bmux_vector) + GetSize(out) - 1) / GetSize(out)));

		// Pad the vector
		int vector_targetlen = GetSize(out) << GetSize(bmux_sel);
		if (vector_targetlen > GetSize(bmux_vector))
			bmux_vector.append(SigSpec(padbit, vector_targetlen - GetSize(bmux_vector)));
		else
			bmux_vector.remove(vector_targetlen, GetSize(bmux_vector) - vector_targetlen);

		// Build the bmux, add an extra mux to handle top bits on the old select signal
		SigSpec bmux_out, out_of_range;
		std::string src = shift->get_src_attribute();
		bmux_out = module->Bmux(NEW_ID, bmux_vector, bmux_sel, src);
		if (GetSize(mul_din) > GetSize(bmux_sel)) {
			out_of_range = module->ReduceBool(NEW_ID, mul_din.extract_end(GetSize(bmux_sel)), false, src);
			module->addMux(NEW_ID, bmux_out, SigSpec(padbit, GetSize(out)), out_of_range, out, src);
		} else {
			module->connect(out, bmux_out);
		}
		autoremove(shift);
		accept;
	} else if (wshift_mode) {
		SigSpec out = port(shift, \Y);
		SigSpec shift_vector = port(shift, \A);
		int shift_stride = mul_const.as_int();
		for (int j = 0; j < shift_stride; j++) {
			SigSpec slice_vector;
			SigSpec slice_out;
			for (int off = j; off < GetSize(shift_vector); off += shift_stride)
				slice_vector.append(shift_vector.extract(off, 1));
			if (param(shift, \A_SIGNED).as_bool())
				slice_vector.append(shift_vector.bits().back());
			for (int off = j; off < GetSize(out); off += shift_stride)
				slice_out.append(out.extract(off, 1));

			if (slice_out.empty()) continue;
			Cell *slice = module->addCell(NEW_ID, shift);
			slice->setParam(\A_WIDTH, GetSize(slice_vector));
			slice->setPort(\A, slice_vector);
			slice->setParam(\B_WIDTH, GetSize(mul_din));
			slice->setParam(\B_SIGNED, Const(1, 0));
			slice->setPort(\B, mul_din);
			slice->setParam(\Y_WIDTH, GetSize(slice_out));
			slice->setPort(\Y, slice_out);
		}
		autoremove(shift);
		accept;
	}

	int const_factor = mul_const.as_int();
	int new_const_factor = 1 << factor_bits;
	SigSpec padding(State::Sx, new_const_factor-const_factor);
	SigSpec old_a = port(shift, \A), new_a;
	int trunc = 0;

	if (GetSize(old_a) % const_factor != 0) {
		trunc = const_factor - GetSize(old_a) % const_factor;
		old_a.append(SigSpec(State::Sx, trunc));
	}

	for (int i = 0; i*const_factor < GetSize(old_a); i++) {
		SigSpec slice = old_a.extract(i*const_factor, const_factor);
		new_a.append(slice);
		new_a.append(padding);
	}

	if (trunc > 0)
		new_a.remove(GetSize(new_a)-trunc, trunc);

	SigSpec new_b = {mul_din, SigSpec(State::S0, factor_bits)};
	if (param(shift, \B_SIGNED).as_bool())
		new_b.append(State::S0);

	shift->setPort(\A, new_a);
	shift->setParam(\A_WIDTH, GetSize(new_a));
	shift->setPort(\B, new_b);
	shift->setParam(\B_WIDTH, GetSize(new_b));

	blacklist(shift);
	accept;
}
endcode
