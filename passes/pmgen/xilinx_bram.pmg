pattern xilinx_bram_pack
state <SigSpec> sigDOA sigDOB

state <SigBit> clock
state <Cell*> ffDOA ffDOAcemux ffDOB ffDOBcemux ffADrstmux ffBDrstmux
state <bool> ffDOAcepol ffDOBcepol ffADrstpol ffBDrstpol

// Variables used for subpatterns
state <SigSpec> argQ argD
state <bool> ffcepol ffrstpol
udata <SigSpec> dffD dffQ
udata <SigBit> dffclock
udata <Cell*> dff dffcemux dffrstmux
udata <bool> dffcepol dffrstpol

// (1) Starting from a RAMB18E1 cell
match bram
	select bram->type.in(\RAMB18E1, \RAMB36E1)
endmatch

code sigDOA argD clock ffDOA ffDOAcemux ffDOAcepol ffADrstmux ffADrstpol
	if (param(bram, \DOA_REG, 0).as_int() == 0) {
		// Select the correct consumers of DOADO port
		for (const auto &b : port(bram, \DOADO))
		{
			// Ignore unused output bits
			if (nusers(b) < 2)
				continue;
			// Only collect output bits with a single sink
			else if (nusers(b) == 2)
                                sigDOA.append(b);
			// Abandon this whole output if any bit
			//   has more than a single sink
                        else if (nusers(b) > 2) {
                                sigDOA = SigSpec();
                                break;
                        }
		}
		// Select the correct consumers of DOAPADOP port
		for (const auto &b : port(bram, \DOPADOP))
		{
			// Ignore unused output bits
			if (nusers(b) < 2)
				continue;
			// Only collect output bits with a single sink
			else if (nusers(b) == 2)
				sigDOA.append(b);
			// Abandon this whole output if any bit
			//   has more than a single sink
			else if (nusers(b) > 2) {
				sigDOA = SigSpec();
				break;
			}
		}

		// Traverse the consumers of sigDOA
		if (!sigDOA.empty()) {
			argD = sigDOA;
			clock = port(bram, \CLKARDCLK);
			subpattern(out_dffe);
			if (dff) {
				ffDOA = dff;
				if (dffrstmux) {
					ffADrstmux = dffrstmux;
					ffADrstpol = dffrstpol;
				}
				if (dffcemux) {
					ffDOAcemux = dffcemux;
					ffDOAcepol = dffcepol;
				}
				sigDOA = dffQ;
			}
		}
	}
endcode

//================== PORT B =============================//
code sigDOB argD clock ffDOB ffDOBcemux ffDOBcepol ffBDrstmux ffBDrstpol
	if (param(bram, \DOB_REG, 0).as_int() == 0) {
		// Select the correct consumers of DOADO port
		for (const auto &b : port(bram, \DOBDO))
		{
			// Ignore unused output bits
			if (nusers(b) < 2)
				continue;
			// Only collect output bits with a single sink
			else if (nusers(b) == 2)
                                sigDOB.append(b);
			// Abandon this whole output if any bit
			//   has more than a single sink
                        else if (nusers(b) > 2) {
                                sigDOB = SigSpec();
                                break;
                        }
		}
		// Select the correct consumers of DOAPADOP port
		for (const auto &b : port(bram, \DOPBDOP))
		{
			// Ignore unused output bits
			if (nusers(b) < 2)
				continue;
			// Only collect output bits with a single sink
			else if (nusers(b) == 2)
				sigDOB.append(b);
			// Abandon this whole output if any bit
			//   has more than a single sink
			else if (nusers(b) > 2) {
				sigDOB = SigSpec();
				break;
			}
		}

		// Traverse the consumers of sigDOA
		if (!sigDOB.empty()) {
			argD = sigDOB;
			clock = port(bram, \CLKARDCLK);
			subpattern(out_dffe);
			if (dff) {
				ffDOB = dff;
				if (dffrstmux) {
					ffBDrstmux = dffrstmux;
					ffBDrstpol = dffrstpol;
				}
				if (dffcemux) {
					ffDOBcemux = dffcemux;
					ffDOBcepol = dffcepol;
				}
				sigDOB = dffQ;
			}
		}
	}
endcode

code
	log_dump(sigDOA, ffDOA, ffDOAcemux, ffDOAcepol, ffADrstmux, ffADrstpol);
	accept;
endcode

subpattern out_dffe
arg argD argQ clock
 
code
	dff = nullptr;
	for (auto c : argD.chunks())
		// Abandon matches when 'D' has the keep attribute set
		if (c.wire->get_bool_attribute(\keep))
			reject;
endcode
 
// (1) Starting from an optional $mux cell that implements clock enable
//     semantics --- one where the given 'D' argument (partially or fully)
//     drives one of its two inputs
match ffcemux
	select ffcemux->type.in($mux)
	// ffcemux output must have two users: ffcemux and ff.D
	select nusers(port(ffcemux, \Y)) == 2
 
	choice <IdString> AB {\A, \B}

	// keep-last-value net must have at least three users: ffcemux, ff, downstream sink(s)
	select nusers(port(ffcemux, AB)) >= 3
 
	slice offset GetSize(port(ffcemux, \Y))
	define <IdString> BA (AB == \A ? \B : \A)
	index <SigBit> port(ffcemux, BA)[offset] === argD[0]
 
	define <bool> pol (AB == \A)
	set ffcepol pol
 
	semioptional
endmatch
 
code argD argQ
	dffcemux = ffcemux;
	if (ffcemux) {
		SigSpec BA = port(ffcemux, ffcepol ? \B : \A);
		SigSpec Y = port(ffcemux, \Y);

		// Check that the rest of argD is present
		auto BAset = BA.to_sigbit_pool();
		for (const auto &b : argD)
			if (!BAset.count(b))
				reject;

		argQ = argD;
		argD.replace(BA, Y);
		argQ.replace(BA, port(ffcemux, ffcepol ? \A : \B));
 
		dffcemux = ffcemux;
		dffcepol = ffcepol;
	}
	log_dump(ffcemux, argD, argQ);
endcode

// (2) Starting from, or continuing onto, another optional $mux cell that
//     implements synchronous reset semantics --- one where the given 'D'
//     argument (or the clock enable $mux output) drives one of its two inputs
//     and where the other input is fully zero
match ffrstmux
	select ffrstmux->type.in($mux)
	// ffrstmux output must have two users: ffrstmux and ff.D
	select nusers(port(ffrstmux, \Y)) == 2

	choice <IdString> BA {\B, \A}

	// Xilinx BRAM only supports registers with zero reset value
	select port(ffrstmux, BA).is_fully_zero()

	slice offset GetSize(port(ffrstmux, \Y))
	define <IdString> AB (BA == \B ? \A : \B)
	index <SigBit> port(ffrstmux, AB)[offset] === argD[0]

	define <bool> pol (AB == \A)
	set ffrstpol pol

	semioptional
endmatch

code argD argQ
	dffrstmux = ffrstmux;
	if (ffrstmux) {
		SigSpec AB = port(ffrstmux, ffrstpol ? \A : \B);
		SigSpec Y = port(ffrstmux, \Y);

		// Check that the rest of argD is present
		auto ABset = AB.to_sigbit_pool();
		for (const auto &b : argD)
			if (!ABset.count(b))
				reject;

		argD.replace(AB, Y);
	
		dffrstmux = ffrstmux;
		dffrstpol = ffrstpol;
	}
	log_dump(ffrstmux, argD, argQ);
endcode
 
// (3) Match for a $dff cell (whose 'D' input is the 'D' argument, or the
//     output of the previous clock enable or reset $mux cells)
match ff
	select ff->type.in($dff)
	
	slice offset GetSize(port(ff, \D))
	index <SigBit> port(ff, \D)[offset] === argD[0] 
 
	// Check that FF.Q is connected to CE-mux
	filter !ffcemux || port(ff, \Q) == port(ffcemux, ffcepol ? \A  : \B)
 
	filter clock == SigBit() || port(ff, \CLK) == clock
endmatch
 
code argQ
	SigSpec D = port(ff, \D);
	SigSpec Q = port(ff, \Q);

	// Check that the rest of argD is present
	auto Dset = D.to_sigbit_pool();
	for (const auto &b : argD)
		if (!Dset.count(b))
			reject;

	if (!ffcemux) {
		argQ = argD;
		argQ.replace(D, Q);
	}
 
	dff = ff;
	dffQ = argQ;
	dffclock = port(ff, \CLK);
	log_dump(ff, dff, dffQ, dffclock);
endcode
