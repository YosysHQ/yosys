pattern xilinx_bram
state <SigSpec> sigP sigM
state <SigBit> clock sigEN

// Variables used for subpatterns
state <SigSpec> argQ argD
state <Cell*> ffD ffDcemux ffM ffMcemux ffP ffPcemux
state <bool> ffA1cepol ffA2cepol ffADcepol ffB1cepol ffB2cepol ffDcepol ffMcepol ffPcepol
state <bool> ffcepol
state <int> ffoffset
udata <Cell*> dff dffcemux 
udata <SigBit> dffclock
udata <bool> dffcepol
udata <SigSpec> dffD dffQ

// (1) Starting from a RAMB18E1 cell
match bram
	select bram->type.in(\RAMB18E1)
endmatch

// Get all BRAM pins needed (in this case, only DOADO, clk, en and that's it?
code sigM sigEN clock
	sigEN = port(bram, \REGCEAREGCE, SigSpec());
	clock = port(bram, \CLKARDCLK, SigBit());
	sigM = port(bram, \DOADO, SigSpec());
endcode

// (1) Match 'DOADO' output that exclusively drives an FDRE
code argD ffM ffMcemux ffMcepol sigM sigP clock
	if (param(bram, \DOA_REG, 0).as_int() == 0 && nusers(sigM) == 2) {
		argD = sigM;
		log("[diego] Signal argD is %s\n", log_signal(argD));
		subpattern(out_dffe);
		if (dff) {
			ffM = dff;
			clock = dffclock;
			if (dffcemux) {
				ffMcemux = dffcemux;
				ffMcepol = dffcepol;
			}
			sigM = dffQ;
		}
	}
	sigP = sigM;
	log("[diego-> SIGNALS] %s, %s, %s, %s, %s, %s, %s\n", 
		log_signal(argD), log_signal(ffM), log_signal(clock),
		log_signal(ffMcemux), log_signal(ffMcepol), log_signal(sigM),
		log_signal(sigP));
endcode


// Part two
subpattern out_dffe
arg argD argQ clock

code
	dff = nullptr;
	for (auto c : argD.chunks())
		// Abandon matches when 'D' has the keep attribute set
		if (c.wire->get_bool_attribute(\keep))
			reject;
endcode

// (1) Starting from an optional $mux cell that implements clock enable
//     semantics --- one where the given 'D' argument (partially or fully)
//     drives one of its two inputs
match ffcemux
	select ffcemux->type.in($mux)
	// ffcemux output must have two users: ffcemux and ff.D
	select nusers(port(ffcemux, \Y)) == 2

	choice <IdString> AB {\A, \B}
	// keep-last-value net must have at least three users: ffcemux, ff, downstream sink(s)
	select nusers(port(ffcemux, AB)) >= 3

	slice offset GetSize(port(ffcemux, \Y))
	define <IdString> BA (AB == \A ? \B : \A)
	index <SigBit> port(ffcemux, BA)[offset] === argD[0]

	// Check that the rest of argD is present
	filter GetSize(port(ffcemux, BA)) >= offset + GetSize(argD)
	filter port(ffcemux, BA).extract(offset, GetSize(argD)) == argD

	set ffoffset offset
	define <bool> pol (AB == \A)
	set ffcepol pol

	semioptional
endmatch

code argD argQ
	dffcemux = ffcemux;
	if (ffcemux) {
		SigSpec BA = port(ffcemux, ffcepol ? \B : \A);
		SigSpec Y = port(ffcemux, \Y);
		argQ = argD;
		argD.replace(BA, Y);
		argQ.replace(BA, port(ffcemux, ffcepol ? \A : \B));

		dffcemux = ffcemux;
		dffcepol = ffcepol;
	}
endcode

// (3) Match for a $dff cell (whose 'D' input is the 'D' argument, or the
//     output of the previous clock enable or reset $mux cells)
match ff
	select ff->type.in($dff)
	// DSP48E1 does not support clock inversion
	select param(ff, \CLK_POLARITY).as_bool()

	slice offset GetSize(port(ff, \D))
	index <SigBit> port(ff, \D)[offset] === argD[0] 
	// this index is not working

	// Check that offset is consistent
	filter (!ffcemux) || ffoffset == offset
	// Check that the rest of argD is present
	filter GetSize(port(ff, \D)) >= offset + GetSize(argD)
	filter port(ff, \D).extract(offset, GetSize(argD)) == argD
	// Check that FF.Q is connected to CE-mux
	filter !ffcemux || port(ff, \Q).extract(offset, GetSize(argQ)) == argQ

	filter clock == SigBit() || port(ff, \CLK) == clock

	set ffoffset offset
endmatch

code argQ
	SigSpec D = port(ff, \D);
	SigSpec Q = port(ff, \Q);
	if (!ffcemux) {
		argQ = argD;
		argQ.replace(D, Q);
	}

	// Abandon matches when 'Q' has a non-zero init attribute set
	// (not supported by DSP48E1)
	for (auto c : argQ.chunks()) {
		Const init = c.wire->attributes.at(\init, Const());
		if (!init.empty())
			for (auto b : init.extract(c.offset, c.width))
				if (b != State::Sx && b != State::S0)
					reject;
	}

	dff = ff;
	dffQ = argQ;
	dffclock = port(ff, \CLK);
	log("[diego] signals from dff filter: %s %s %s\n",
		log_signal(dff), log_signal(dffQ), log_signal(dffclock));
endcode
